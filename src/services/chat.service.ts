import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ChatSession } from '../entities/chat-session.entity';
import { User } from '../entities/user.entity';
import { Script } from '../entities/script.entity';
import { Scene } from '../entities/scene.entity';
import { MediaFile, MediaType } from '../entities/media-file.entity';
import { OpenAIService } from './openai.service';
import { SSEService } from './sse.service';
import { S3Service, ChatMessage } from './s3.service';
import { v4 as uuidv4 } from 'uuid';
import {
  CreateChatSessionDto,
  SendMessageDto,
  ChatSessionDto,
} from '../dto/chat.dto';
import { GoogleGenAIService } from './google.gen.ai.service';
import { GenerateImagesResponse } from '@google/genai';

@Injectable()
export class ChatService {
  constructor(
    @InjectRepository(ChatSession)
    private chatSessionRepository: Repository<ChatSession>,
    @InjectRepository(Script)
    private scriptRepository: Repository<Script>,
    @InjectRepository(Scene)
    private sceneRepository: Repository<Scene>,
    @InjectRepository(MediaFile)
    private mediaFileRepository: Repository<MediaFile>,
    private openaiService: OpenAIService,
    private googleGenAIService: GoogleGenAIService,
    private sseService: SSEService,
    private s3Service: S3Service,
  ) {}

  async createChatSession(
    userId: string,
    createDto: CreateChatSessionDto,
  ): Promise<ChatSessionDto> {
    const chatSession = this.chatSessionRepository.create({
      ...createDto,
      userId,
    });

    const savedSession = await this.chatSessionRepository.save(chatSession);

    await this.s3Service.uploadChatFile(savedSession.id, []);

    savedSession.s3ChatFileKey = this.s3Service.generateChatFileKey(
      savedSession.id,
    );
    // URL will be generated by S3Service based on MinIO/AWS configuration
    savedSession.s3ChatFileUrl = await this.s3Service.getSignedDownloadUrl(
      savedSession.s3ChatFileKey,
      86400,
    ); // 24 hours
    await this.chatSessionRepository.save(savedSession);

    this.sseService.broadcastToUser(userId, {
      type: 'chat_session_created',
      data: this.mapToChatSessionDto(savedSession),
    });

    return this.mapToChatSessionDto(savedSession);
  }

  async getChatSessions(userId: string): Promise<ChatSessionDto[]> {
    const sessions = await this.chatSessionRepository.find({
      where: { userId },
      relations: ['mediaFiles'],
      order: { updatedAt: 'DESC' },
    });

    return sessions.map((session) => this.mapToChatSessionDto(session));
  }

  async getChatSession(
    userId: string,
    sessionId: string,
  ): Promise<ChatSessionDto> {
    const session = await this.chatSessionRepository.findOne({
      where: { id: sessionId, userId },
      relations: ['mediaFiles'],
    });

    if (!session) {
      throw new Error('Chat session not found');
    }

    const messages = await this.s3Service.downloadChatFile(sessionId);

    return {
      ...this.mapToChatSessionDto(session),
      messages: messages.map((msg) => ({
        id: msg.id,
        role: msg.role,
        type: msg.type,
        content: msg.content,
        metadata: msg.metadata,
        createdAt: new Date(msg.timestamp),
      })),
    };
  }

  async sendMessageStream(
    userId: string,
    sendDto: SendMessageDto,
    streamCallback: (chunk: any) => void,
  ): Promise<void> {
    let chatSession: ChatSession | null;

    if (sendDto.chatSessionId) {
      chatSession = await this.chatSessionRepository.findOne({
        where: { id: sendDto.chatSessionId, userId },
      });
    } else {
      chatSession = this.chatSessionRepository.create({
        title: 'New Chat',
        userId,
      });

      await this.chatSessionRepository.save(chatSession);
    }

    const userMessage: ChatMessage = {
      id: uuidv4(),
      role: 'user',
      type: 'text',
      content: sendDto.content,
      timestamp: new Date().toISOString(),
    };

    chatSession!.messageCount += 1;
    chatSession!.lastMessageAt = new Date();

    streamCallback({
      type: 'ai_chat_session_created',
      data: {
        message: userMessage,
        sessionId: chatSession!.id,
      },
    });

    this.sseService.broadcastToSession(chatSession!.id, {
      type: 'new_message',
      data: {
        message: userMessage,
        sessionId: chatSession!.id,
      },
    });

    streamCallback({
      type: 'ai_processing_started',
      data: {
        sessionId: chatSession!.id,
      },
    });

    try {
      const aiResponse = await this.processWithAIStream(
        sendDto.content,
        userId,
        chatSession!.id,
        'script',
        streamCallback,
      );

      this.sseService.broadcastToSession(chatSession!.id, {
        type: 'new_message',
        data: {
          message: aiResponse,
          sessionId: chatSession!.id,
        },
      });

      streamCallback({
        type: 'ai_response_complete',
        data: {
          message: aiResponse,
          sessionId: chatSession!.id,
        },
      });
    } catch (error) {
      streamCallback({
        type: 'ai_error',
        data: {
          error: error,
          sessionId: chatSession!.id,
        },
      });
      throw error;
    }
  }

  async uploadMediaFile(
    userId: string,
    chatSessionId: string,
    file: Buffer,
    originalName: string,
    mimeType: string,
  ): Promise<MediaFile> {
    const chatSession = await this.chatSessionRepository.findOne({
      where: { id: chatSessionId, userId },
    });

    if (!chatSession) {
      throw new Error('Chat session not found');
    }

    const uploadResult = await this.s3Service.uploadMediaFile(
      file,
      originalName,
      mimeType,
    );

    let mediaType = MediaType.DOCUMENT;
    if (mimeType.startsWith('image/')) {
      mediaType = MediaType.IMAGE;
    } else if (mimeType.startsWith('video/')) {
      mediaType = MediaType.VIDEO;
    } else if (mimeType.startsWith('audio/')) {
      mediaType = MediaType.AUDIO;
    }

    const mediaFile = this.mediaFileRepository.create({
      fileName: uploadResult.key.split('/').pop() || originalName,
      originalName,
      mimeType,
      fileSize: uploadResult.size,
      mediaType,
      s3Key: uploadResult.key,
      s3Url: uploadResult.url,
      chatSessionId,
    });

    const savedMediaFile = await this.mediaFileRepository.save(mediaFile);

    const mediaMessage: ChatMessage = {
      id: uuidv4(),
      role: 'user',
      type: 'image',
      content: uploadResult.url,
      metadata: {
        mediaFileId: savedMediaFile.id,
        originalName,
        mimeType,
        fileSize: uploadResult.size,
      },
      timestamp: new Date().toISOString(),
    };

    await this.s3Service.appendMessageToChat(chatSessionId, mediaMessage);

    chatSession.messageCount += 1;
    chatSession.lastMessageAt = new Date();
    await this.chatSessionRepository.save(chatSession);

    this.sseService.broadcastToSession(chatSessionId, {
      type: 'media_uploaded',
      data: {
        mediaFile: savedMediaFile,
        message: mediaMessage,
        sessionId: chatSessionId,
      },
    });

    return savedMediaFile;
  }

  private async processWithAI(
    userMessage: string,
    userId: string,
    sessionId: string,
    stream_response: boolean,
    streamCallback: (chunk: any) => void,
  ): Promise<ChatMessage> {
    try {
      if (stream_response) {
        streamCallback({
          type: 'ai_script_generation_started',
          data: {
            message: 'Starting to Generate Images',
            sessionId: sessionId,
          },
        });

        const scriptMessage = await this.handleScriptGeneration(
          userMessage,
          userId,
          sessionId,
          stream_response,
          streamCallback,
        );

        const imageGenResponse = await this.handleImageGeneration(
          scriptMessage.content,
          userId,
          sessionId,
          stream_response,
          streamCallback,
        );

        if (imageGenResponse === null || imageGenResponse === undefined) {
          streamCallback({
            type: 'ai_image_generation_error',
            data: {
              message: 'Error while generating Image',
              sessionId: sessionId,
            },
          });
        } else {
          streamCallback({
            type: 'ai_video_generation_started',
            data: {
              message: 'Video Generation Started',
              sessionId: sessionId,
            },
          });

          const videoGen = await this.googleGenAIService.generateImageToVideo(
            imageGenResponse as GenerateImagesResponse,
            scriptMessage.content,
          );

          streamCallback({
            type: 'ai_video_saved',
            data: {
              message: {
                videoPath: videoGen,
              },
              sessionId: sessionId,
            },
          });
        }
      }

      return {
        id: uuidv4(),
        role: 'system',
        type: 'text',
        content: 'Generation Complete',
        timestamp: new Date().toISOString(),
      };
    } catch (err) {
      return {
        id: uuidv4(),
        role: 'system',
        type: 'error',
        content: 'Generation Failed',
        timestamp: new Date().toISOString(),
      };
    }
  }

  private async processWithAIStream(
    content: string,
    userId: string,
    sessionId: string,
    message_type: string,
    streamCallback: (chunk: any) => void,
  ): Promise<ChatMessage> {
    const aiMessage: ChatMessage = {
      id: uuidv4(),
      role: 'assistant',
      type: 'text',
      content: '',
      timestamp: new Date().toISOString(),
    };

    streamCallback({
      type: 'ai_message_start',
      data: {
        message: aiMessage,
        sessionId,
      },
    });

    try {
      const aiMessage = await this.processWithAI(
        content,
        userId,
        sessionId,
        true,
        streamCallback,
      );

      return aiMessage;
    } catch (error) {
      console.warn(
        'AI streaming failed, falling back to regular processing:',
        error,
      );

      const response = await this.processWithAI(
        content,
        userId,
        sessionId,
        false,
        streamCallback,
      );
      aiMessage.content = response.content;
      const words = response.content.split(' ');
      for (let i = 0; i < words.length; i++) {
        const chunk = words.slice(0, i + 1).join(' ');
        aiMessage.content = chunk;

        streamCallback({
          type: 'ai_message_chunk',
          data: {
            chunk: words[i] + ' ',
            message: { ...aiMessage },
            sessionId,
          },
        });
      }

      return aiMessage;
    }
  }

  private async handleScriptGeneration(
    userMessage: string,
    userId: string,
    sessionId: string,
    stream_response: boolean,
    streamCallback: (chunk: any) => void,
  ): Promise<ChatMessage> {
    const genreMatch = userMessage.match(/(?:genre|type|style):\s*(\w+)/i);
    const genre = genreMatch ? genreMatch[1] : undefined;

    const scriptContent = await this.openaiService.generateScript(
      userMessage,
      stream_response,
      streamCallback,
      sessionId,
      genre,
    );

    const toolResultMessage: ChatMessage = {
      id: uuidv4(),
      role: 'assistant',
      type: 'script',
      content: scriptContent,
      metadata: {},
      timestamp: new Date().toISOString(),
    };

    return toolResultMessage;
  }

  private async handleImageGeneration(
    userMessage: string,
    userId: string,
    sessionId: string,
    stream_response: boolean,
    streamCallback: (chunk: any) => void,
  ): Promise<GenerateImagesResponse | null | string> {
    let imagePrompt = userMessage;

    imagePrompt = await this.openaiService.generateSceneDescription(
      userMessage,
      stream_response,
      streamCallback,
      sessionId,
    );

    streamCallback({
      type: 'ai_image_generation_started',
      data: {
        message: 'Starting to Generate Images',
        sessionId: sessionId,
      },
    });

    const imageGenResponse = await this.googleGenAIService.generateImage(
      imagePrompt,
      streamCallback,
    );

    if (
      imageGenResponse !== null &&
      imageGenResponse !== undefined &&
      imageGenResponse.generatedImages !== undefined
    ) {
      streamCallback({
        type: 'ai_image_generation_completed',
        data: {
          message: imageGenResponse?.generatedImages[0],
          sessionId: sessionId,
        },
      });
    }
    return imageGenResponse;
  }

  private async handleDefaultResponse(
    userMessage: string,
    sessionId: string,
    stream_response: boolean,
    streamCallback: (chunk: any) => void,
  ): Promise<ChatMessage> {
    const response = await this.openaiService.generateScript(
      `User message: ${userMessage}\n\nPlease provide a helpful response about movie script writing, scene generation, or creative filmmaking.`,
      stream_response,
      streamCallback,
      sessionId,
    );

    return {
      id: uuidv4(),
      role: 'assistant',
      type: 'text',
      content: response,
      timestamp: new Date().toISOString(),
    };
  }

  private mapToChatSessionDto(session: ChatSession): ChatSessionDto {
    return {
      id: session.id,
      title: session.title,
      description: session.description,
      messages: [],
      mediaFiles:
        session.mediaFiles?.map((media) => ({
          id: media.id,
          fileName: media.fileName,
          originalName: media.originalName,
          mimeType: media.mimeType,
          fileSize: media.fileSize,
          mediaType: media.mediaType,
          s3Url: media.s3Url,
          thumbnailUrl: media.thumbnailUrl,
          metadata: media.metadata,
          createdAt: media.createdAt,
        })) || [],
      messageCount: session.messageCount,
      lastMessageAt: session.lastMessageAt,
      createdAt: session.createdAt,
      updatedAt: session.updatedAt,
    };
  }
}
